---
title: "Hands-on_Ex2"
subtitle: "2nd date with Geospatial"
date: "22 Nov 2023"
date-modified: "last-modified"
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

## Getting Started

Lets make make sure that **spdep**, **sf**, **tmap** and **tidyverse** packages of R are currently installed 

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

## Importing Geosptial Data into R

### Importing shapefile into R env

The code chunk below uses st_read() of sf package to import Hunan shapefile into R. The imported shapefile will be simple features Object of sf.

```{r}
hunan <- st_read(dsn = "data/geospatial", layer = "Hunan")
```

### Importing CSV file into into R env

```{r}
hunan2012 <- read.csv("data/aspatial/Hunan_2012.csv")

```

### Performing relational join

Using *left_join()* of **dplyr** package to update the attribute table of *hunan*'s SpatialPolygonsDataFrame with the attribute fields of *hunan2012* dataframe.

```{r}
hunan <- left_join(hunan,hunan2012)%>%
  select(1:4, 7, 15)
```

## Visualising Regional Development Indicator

### Preparing a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.

```{r}
basemap <- tm_shape(hunan) + tm_polygons() + tm_text("NAME_3",size = 0.5)
gdppc <- qtm(hunan,"GDPPC")
tmap_arrange(basemap,gdppc,asp=1,ncol=2)
```

## Computing Contiguity Spatial Weights

In spatial analysis - a neighborhood refers to those data points that we consider to be proximate to a given focal data point. With area-based vector data (polygons), there are multiple ways to measure proximity:

1.  Contiguity-based neighbors consider neighboring polygons to be those that "touch" a focal polygon, and are derived in spdep package with the poly2nb() function

2.  Distance-based neighbors are those within a given proximity threshold to a focal polygon; distances are measured between polygon centroid using the knn2nb() function

Contiguity happens when two spatial units share a common border.

Queen Contiguity: A neigboring polygon is one that shares a vertex with the focal polygon Rook Contiguity: A neigboring polygon is one that shares an edge (line segment) with the focal polygon

### Computing (QUEEN) contiguity based neighbours

[*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package to compute contiguity weight matrices for the study area.

```{r}
pacman::p_load(spdep)
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```
The summary report shows that:

There are 88 area units in Hunan
The most connected area unit has 11 neighbors (links)
The two least connected areas have only 1 neighbor

For each polygon in our polygon object, wm_q lists all neighboring polygons. For example, to see the neighbors for the first polygon in the object, type:
```{r}
wm_q[[1]]
```
Polygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.

We can retrive the county name of Polygon ID=1 by using the code chunk below:

```{r}
hunan$NAME_3[1]
```

To reveal the county names of the five neighboring polygons:

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

To retrieve the GDPPC of these five countries:

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

The printed output above shows that the GDPPC of the five nearest neighbours based on Queen's method are 20981, 34592, 24473, 21311 and 22879 respectively.

```{r}
str(wm_q)
```

### Creating (ROOK) contiguity based neighbours

To compute Rook contiguity weight matrix:

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

The summary report shows that:

There are 88 area units in Hunan
The most connected area unit has 10 neighbors (links)
The two least connected areas have only 1 neighbor

### Visualising contiguity weight
A connectivity graph takes a point and displays a line connecting to each neighboring point. The current geospatial dataset only has polygons at the moment, so we will need to compute points in order to make our connectivity graphs. The most typical method for this will be using polygon centroids.

```{r}
pacman::p_load(purrr)
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
coords <- cbind(longitude, latitude)
head(coords)
```

#### Plotting Queen contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

#### Plotting Rook contiguity based neighbours map

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "yellow")
```

## Computing distance based neighbours

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

The summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour.

### Computing fixed distance weight matrix

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

use *str()* to display the content of wm_d62 weight matrix

```{r}
str(wm_d62)
```

Another way to display the structure of the weight matrix is to combine [*table()*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/table) and [*card()*](https://r-spatial.github.io/spdep/reference/card.html) of spdep.

```{r}
table(hunan$County, card(wm_d62))
```
#### Plotting fixed distance weight matrix
Next, we will plot the distance weight matrix by using the code chunk below.
```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```
The red lines show the links of 1st nearest neighbours and the black lines show the links of neighbours within the cut-off distance of 62km.

Alternatively, we can plot both of them next to each other by using the code chunk below.

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="1st nearest neighbours")
plot(k1, coords, add=TRUE, col="red", length=0.08)
plot(hunan$geometry, border="lightgrey", main="Distance link")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)

```
### Computing adaptive distance weight matrix

In fixed distance weight matrices, more densely populated areas (usually the urban areas) tend to have more neighbors and the less densely settled areas (usually the rural counties) tend to have fewer neighbors. Having many neighbors smoothes the neighbor relationship across more neighbors.

It is possible to control the numbers of neighbors directly using k-nearest neighbors, either accepting asymmetric neighbors or imposing symmetry – stating k = n as a parameter where n = number of neighbors:

```{r}
knn6 <- knn2nb(knearneigh(coords, k=6))
knn6
```
#### Plotting distance based neighbours

```{r}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```
## Computing Inversed Distance Weights (IDW)

Derive a spatial weight matrix based on the Inversed Distance method.

### 1.) Compute the distances between areas by using nbdists() of spdep.
```{r}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```
### 2.) Assign weights to each neighboring polygon
```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```
The zero.policy=TRUE option allows for lists of non-neighbors. This should be used with caution since the user may not be aware of missing neighbors in their dataset however, a zero.policy of FALSE would return an error.

To see the weight of the first polygon\'s eight neighbors type:

```{r}
rswm_q$weights[10]

```
Each neighbor is assigned a 0.125 of the total weight. This means that when R computes the average neighboring income values, each neighbor’s income will be multiplied by 0.2 before being tallied.

Using the same method, we can also derive a row standardised distance weight matrix by using the code chunk below.

```{r}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```

```{r}
summary(unlist(rswm_ids$weights))
```

## Application of Spatial Weight Matrix

### Spatial lag with row-standardized weights
