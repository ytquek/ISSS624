---
title: "Hands-on_3"
subtitle: "Hands-On 3: Local Measures of Spatial Autocorrelation"
date: "29 Nov 2023"
date-modified: "last-modified"
format: html
editor: visual
---

## Getting Started

### Import packages

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse)
```

### **Import shapefile into r environment**

```{r}
getwd()
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
```

### **Import csv file into r environment**

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

### **Performing relational join**

```{r}
hunan <- left_join(hunan,hunan2012) %>%
  select(1:4, 7, 15)
```

### **Visualising Regional Development Indicator**

```{r}
equal <- tm_shape(hunan) +
  tm_fill("GDPPC",
          n = 5,
          style = "equal") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal interval classification")

quantile <- tm_shape(hunan) +
  tm_fill("GDPPC",
          n = 5,
          style = "quantile") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal quantile classification")

tmap_arrange(equal, 
             quantile, 
             asp=1, 
             ncol=2)
```

## **Global Spatial Autocorrelation**

### **Computing Contiguity Spatial Weights**

compute Queen contiguity weight matrix

```{r}
wm_q <- poly2nb(hunan, 
                queen=TRUE)
summary(wm_q)
```

The summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one neighbours.

### **Row-standardised weights matrix**

```{r}
rswm_q <- nb2listw(wm_q, 
                   style="W", 
                   zero.policy = TRUE)
rswm_q
```

### **Global Spatial Autocorrelation: Moran's I**

```{r}
moran.test(hunan$GDPPC, 
           listw=rswm_q, 
           zero.policy = TRUE, 
           na.action=na.omit)
```

The Moran's I test results show a Moran I statistic significantly greater than expected under spatial randomness (p-value \< 0.05). The positive value of Moran's I suggests a clustered spatial pattern, meaning that similar values tend to be close to each other in space.

#### Computing Monte Carlo Moran's I

```{r}
set.seed(1234)
bperm= moran.mc(hunan$GDPPC, 
                listw=rswm_q, 
                nsim=999, 
                zero.policy = TRUE, 
                na.action=na.omit)
bperm
```

The p-value of 0.001 is below the common significance level of 0.05. Therefore, we can conclude that the observed Moran's I is statistically significant, and there is strong evidence to reject the null hypothesis of spatial randomness. The positive Moran's I suggests a spatial clustering pattern in the data.

#### Visualising Monte Carlo Moran's I

##### Using Base Graph to plot the values：

```{r}
mean(bperm$res[1:999])
```

```{r}
var(bperm$res[1:999])
```

```{r}
summary(bperm$res[1:999])
```

```{r}
hist(bperm$res, 
     freq=TRUE, 
     breaks=20, 
     xlab="Simulated Moran's I")
abline(v=0, 
       col="red") 
```

The negative mean suggests a tendency toward spatial dispersion. The red line at 0 indicates where the observed Moran's I falls in the distribution. the red line is far from the bulk of the distribution, it suggests that the observed Moran's I is significantly different from what would be expected under spatial randomness.

##### Using ggplot2 package:

```{r}
library(ggplot2)

ggplot2data <- data.frame(res = bperm$res[1:999])

ggplot(ggplot2data, aes(x=res)) +
  geom_histogram(aes(y=after_stat(density)), colour="black", fill="white", bins=20) +
  geom_density(alpha=.2, fill="#FF6666") + 
  geom_vline(aes(xintercept=mean(res)), color="blue", linetype="dashed", size=1) +
  labs(x="Simulated Moran's I", y="Density") +
  theme_minimal()

```

### **Global Spatial Autocorrelation: Geary's**

#### Geary's C test

```{r}
geary.test(hunan$GDPPC, listw=rswm_q)
```

Geary C statistic significantly less than expected under spatial randomness (p-value \< 0.05). Therefore, we can conclude that there is negative spatial autocorrelation in the data. The lower-than-expected Geary's C suggests a spatial pattern where neighboring values are less similar than would be expected by random chance.

#### Computing Monte Carlo Geary's C

```{r}
set.seed(1234)
bperm=geary.mc(hunan$GDPPC, 
               listw=rswm_q, 
               nsim=999)
bperm
```

The p-value of 0.001 \<0.05. we can conclude that the observed Geary's C is statistically significant, and there is strong evidence to reject the null hypothesis of spatial randomness. The greater-than-expected Geary's C suggests a spatial pattern where neighboring values are less similar than would be expected by random chance

#### Visualising the Monte Carlo Geary's C

```{r}
mean(bperm$res[1:999])
```

```{r}
var(bperm$res[1:999])
```

```{r}
summary(bperm$res[1:999])
```

```{r}
hist(bperm$res, freq=TRUE, breaks=20, xlab="Simulated Geary c")
abline(v=1, col="red") 
```

The histogram shows the frequency distribution of `bperm$res`. The red line represents the theoretical value of Geary c = 1, and it can be seen that most of the simulated values are distributed around 1, which may indicate weak spatial autocorrelation.

## **Spatial Correlogram**

### **Compute Moran's I correlogram**

```{r}
MI_corr <- sp.correlogram(wm_q, 
                          hunan$GDPPC, 
                          order=6, 
                          method="I", 
                          style="W")
plot(MI_corr)
```

```{r}
print(MI_corr)
```

-   Significant positive spatial autocorrelation is observed at shorter distances (lag 1, lag 2, lag 3), indicating that nearby regions tend to have similar values.

-   A significant negative spatial autocorrelation is observed at longer distances (lag 5, lag 6), suggesting a pattern where regions farther apart have dissimilar values.

-   The Moran's I values are statistically significant for lags 1, 2, 3, 5, and 6, indicating a non-random spatial pattern in the distribution of GDPPC.

### **Compute Geary's C correlogram and plot**

```{r}
GC_corr <- sp.correlogram(wm_q, 
                          hunan$GDPPC, 
                          order=6, 
                          method="C", 
                          style="W")
plot(GC_corr)
```

```{r}
print(GC_corr)
```

## **Cluster and Outlier Analysis**

### **Computing local Moran's I**

```{r}
fips <- order(hunan$County)
localMI <- localmoran(hunan$GDPPC, rswm_q)
head(localMI)
```

```{r}
printCoefmat(data.frame(
  localMI[fips,], 
  row.names=hunan$County[fips]),
  check.names=FALSE)
```

#### Mapping the local Moran's I

```{r}
hunan.localMI <- cbind(hunan,localMI) %>%
  rename(Pr.Ii = Pr.z....E.Ii..)
```

#### Mapping local Moran's I values

```{r}
tm_shape(hunan.localMI) +
  tm_fill(col = "Ii", 
          style = "pretty",
          palette = "RdBu",
          title = "local moran statistics") +
  tm_borders(alpha = 0.5)
```

#### Mapping local Moran's I p-values

```{r}
tm_shape(hunan.localMI) +
  tm_fill(col = "Pr.Ii", 
          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
          palette="-Blues", 
          title = "local Moran's I p-values") +
  tm_borders(alpha = 0.5)
```

#### Mapping both local Moran's I values and p-values

```{r}
localMI.map <- tm_shape(hunan.localMI) +
  tm_fill(col = "Ii", 
          style = "pretty", 
          title = "local moran statistics") +
  tm_borders(alpha = 0.5)

pvalue.map <- tm_shape(hunan.localMI) +
  tm_fill(col = "Pr.Ii", 
          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
          palette="-Blues", 
          title = "local Moran's I p-values") +
  tm_borders(alpha = 0.5)

tmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)
```

## **Creating a LISA Cluster Map**

### **Plotting Moran scatterplot**

```{r}
nci <- moran.plot(hunan$GDPPC, rswm_q,
                  labels=as.character(hunan$County), 
                  xlab="GDPPC 2012", 
                  ylab="Spatially Lag GDPPC 2012")
```

### **Plotting Moran scatterplot with standardised variable**

```{r}
hunan$Z.GDPPC <- scale(hunan$GDPPC) %>% 
  as.vector 
```

```{r}
nci2 <- moran.plot(hunan$Z.GDPPC, rswm_q,
                   labels=as.character(hunan$County),
                   xlab="z-GDPPC 2012", 
                   ylab="Spatially Lag z-GDPPC 2012")
```

### **Preparing LISA map classes**

```{r}
quadrant <- vector(mode="numeric",length=nrow(localMI))
```

```{r}
hunan$lag_GDPPC <- lag.listw(rswm_q, hunan$GDPPC)
DV <- hunan$lag_GDPPC - mean(hunan$lag_GDPPC)     
```

```{r}
LM_I <- localMI[,1] - mean(localMI[,1])    
```

```{r}
signif <- 0.05       
```

```{r}
quadrant[DV <0 & LM_I>0] <- 1
quadrant[DV >0 & LM_I<0] <- 2
quadrant[DV <0 & LM_I<0] <- 3  
quadrant[DV >0 & LM_I>0] <- 4      
```

```{r}
quadrant[localMI[,5]>signif] <- 0
```

### **Plotting LISA map**

```{r}
hunan.localMI$quadrant <- quadrant
colors <- c("#ffffff", "#2c7bb6", "#abd9e9", "#fdae61", "#d7191c")
clusters <- c("insignificant", "low-low", "low-high", "high-low", "high-high")

tm_shape(hunan.localMI) +
  tm_fill(col = "quadrant", 
          style = "cat", 
          palette = colors[c(sort(unique(quadrant)))+1], 
          labels = clusters[c(sort(unique(quadrant)))+1],
          popup.vars = c("")) +
  tm_view(set.zoom.limits = c(11,17)) +
  tm_borders(alpha=0.5)
```

```{r}
gdppc <- qtm(hunan, "GDPPC")

hunan.localMI$quadrant <- quadrant
colors <- c("#ffffff", "#2c7bb6", "#abd9e9", "#fdae61", "#d7191c")
clusters <- c("insignificant", "low-low", "low-high", "high-low", "high-high")

LISAmap <- tm_shape(hunan.localMI) +
  tm_fill(col = "quadrant", 
          style = "cat", 
          palette = colors[c(sort(unique(quadrant)))+1], 
          labels = clusters[c(sort(unique(quadrant)))+1],
          popup.vars = c("")) +
  tm_view(set.zoom.limits = c(11,17)) +
  tm_borders(alpha=0.5)

tmap_arrange(gdppc, LISAmap, 
             asp=1, ncol=2)
```

#Question: What statistical observations can you draw from the LISA map above?

## **Hot Spot and Cold Spot Area Analysis**

### **Getis and Ord's G-Statistics**

### **Deriving distance-based weight matrix**

#### Deriving the centroid

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

```{r}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

```{r}
coords <- cbind(longitude, latitude)
```

#### Determine the cut-off distance

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

The summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour.

#### Computing fixed distance weight matrix

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

```{r}
wm62_lw <- nb2listw(wm_d62, style = 'B')
summary(wm62_lw)
```

### **Computing adaptive distance weight matrix**

```{r}
knn <- knn2nb(knearneigh(coords, k=8))
knn
```

```{r}
knn_lw <- nb2listw(knn, style = 'B')
summary(knn_lw)
```

## **Computing Gi statistics**

### **Gi statistics using fixed distance**

```{r}
fips <- order(hunan$County)
gi.fixed <- localG(hunan$GDPPC, wm62_lw)
gi.fixed
```

```{r}
hunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>%
  rename(gstat_fixed = as.matrix.gi.fixed.)
```

### **Mapping Gi values with fixed distance weights**

```{r}
gdppc <- qtm(hunan, "GDPPC")

Gimap <-tm_shape(hunan.gi) +
  tm_fill(col = "gstat_fixed", 
          style = "pretty",
          palette="-RdBu",
          title = "local Gi") +
  tm_borders(alpha = 0.5)

tmap_arrange(gdppc, Gimap, asp=1, ncol=2)
```

#Question: What statistical observation can you draw from the Gi map above?

### **Gi statistics using adaptive distance**

```{r}
fips <- order(hunan$County)
gi.adaptive <- localG(hunan$GDPPC, knn_lw)
hunan.gi <- cbind(hunan, as.matrix(gi.adaptive)) %>%
  rename(gstat_adaptive = as.matrix.gi.adaptive.)
```

### **Mapping Gi values with adaptive distance weights**

```{r}
gdppc<- qtm(hunan, "GDPPC")

Gimap <- tm_shape(hunan.gi) + 
  tm_fill(col = "gstat_adaptive", 
          style = "pretty", 
          palette="-RdBu", 
          title = "local Gi") + 
  tm_borders(alpha = 0.5)

tmap_arrange(gdppc, 
             Gimap, 
             asp=1, 
             ncol=2)
```

#Question: What statistical observation can you draw from the Gi map above?
